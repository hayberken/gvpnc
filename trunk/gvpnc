#!/usr/bin/env python
# coding=UTF-8

# gvpnc v. 1.01
# Copyright © 2007, Super Mike

# A GUI for the vpnc command (distributed separately)

# You may change and re-release as commercial and customized versions per the license. See artistic license.


# the imports below I just pulled from boilerplate from redhat control panels
# and then added others as I received errors
import sys
import os
import subprocess
import string
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.gdk
import gtk.glade

# assign our globals
global txtResultFont
global window

CONFIGDIR = os.path.expanduser("~/.config/gvpnc")
CONFIGFILE = "default.conf"

# our signal handling (mostly in menu order)
def on_Run(*args):
	gateway = group = group_pwd = username = password = None
	try:
		lines = open(os.path.join(CONFIGDIR, CONFIGFILE),"r").readlines()
		for line in lines:
			if line.startswith("IPSec gateway"):
				gateway = line.split()[2]
			elif line.startswith("IPSec ID"):
				group = line.split()[2]
			elif line.startswith("IPSec secret"):
				group_pwd = line.split()[2]
			elif line.startswith("Xauth username"):
				username = line.split()[2]
			elif line.startswith("Xauth password"):
				password = line.split()[2]
	except (IOError):
		pass

	SetWidgetText('run_server',gateway)
	Widget('run_password').grab_focus()
	SetWidgetText('run_groupname',group)
	SetWidgetText('run_grouppassword',group_pwd)
	SetWidgetText('run_username',username)
	SetWidgetText('run_password',password)
	ShowWindow('run_command')

def on_Quit(*args):
	QuitAll()

def on_About(*args):
	MessageBox("\n\n\tGnome Cisco VPN Connector GUI (gvpnc)\t\t\n\tCopyright © 2007, Super Mike, v. 1.01\t\t\n\n\tThe component vpnc is required and\n\tis not shippped with this GUI. As of\n\tthis build, vpnc copyrights were listed\n\tas: Copyright (C) 2002-2004 Geoffrey\n\tKeating, Maurice Massar. Without their\n\tefforts, gvpnc could not be possible.\n\t\t\n\n\tThis GUI is distributed on the Artistic License.\n\t\t")

# and now the ancillary signals

def on_RunNow(*args):
	sServer = GetWidgetText('run_server')
	sGroup = GetWidgetText('run_groupname')
	sGroupPass = GetWidgetText('run_grouppassword')
	sUser = GetWidgetText('run_username')
	sPass = GetWidgetText('run_password')
	config = file(os.path.join(CONFIGDIR, CONFIGFILE), "w+")
	config.write("# AUTOGENERATED BY gvpnc\n")
	config.write("IPSec gateway "+sServer+"\n")
	config.write("IPSec ID "+sGroup+"\n")
	config.write("IPSec secret "+sGroupPass+"\n")
	config.write("Xauth username "+sUser+"\n")
	config.write("Xauth password "+sPass+"\n")
	config.close()
	HideWindow('run_command')
	Refresh()
	Refresh()

# this doesn't work.  It leaves python running at 100% CPU
#	proc = subprocess.Popen(["gksudo", "vpnc", os.path.join(CONFIGDIR, CONFIGFILE)],
#												stderr=subprocess.PIPE, stdout=subprocess.PIPE)
#	output, error = proc.communicate()

#using this method instead
	Result = subprocess.call(["gksudo", "vpnc", os.path.join(CONFIGDIR, CONFIGFILE)])
	if Result:
		Status('Server: ' + sServer + ' Failed to Connect.')
	else:
		Status('Server: ' + sServer + ' CONNECTED')
#	SetWidgetText('txtResult', sResult)

def on_Stop(*args):
	sServer = GetWidgetText('run_server')
	Result = subprocess.call(["gksudo", "vpnc-disconnect"])
	if Result:
		Status("No vpnc found running.")
	else:
		Status('Server: ' + sServer + ' Disconnected')
#	SetWidgetText('txtResult', sResult)

def on_RunCancel(*args):
	HideWindow('run_command')

def on_AboutClose(*args):
	HideWindow('about')

# and now our functions to make life easier

def GetWidgetText(sName):
	sResult = ''
	try: # for ordinary text fields
		sResult = Widget(sName).get_text()
	except:
		try: # for scrolling textboxes
			c1 = Widget(sName).get_buffer().get_start_iter()
			c2 = Widget(sName).get_buffer().get_end_iter()
			sResult = Widget(sName).get_buffer().get_slice(c1,c2,True)
		except:
			pass
	if (sResult == ''):
		try: # for scrolling textboxes
			c1 = Widget(sName).get_buffer().get_start_iter()
			c2 = Widget(sName).get_buffer().get_end_iter()
			sResult = Widget(sName).get_buffer().get_slice(c1,c2,True)
		except:
			sResult = ''
	return sResult

def SetWidgetText(sName, sText):
	if (sText == ''):
		try:
			aReset = string.split('\n', "\n")
			Widget(sName).set_popdown_strings(aReset)
		except:
			pass
	try:
		Widget(sName).get_buffer().set_text(sText)
	except:
		try:
			Widget(sName).set_text(sText)
		except:
			return

def Widget(sName):
	return MyWindows.get_widget(sName)

def ShowWindow(thewindow):
    Widget(thewindow).show()

def HideWindow(thewindow):
    Widget(thewindow).hide()

def Destroy(thewindow):
    Widget(thewindow).destroy()

def SetResultFont(*args):
	o = args[0].get_buffer()
	c1 = o.get_start_iter()
	c2 = o.get_end_iter()
	o.apply_tag(txtResultFont,c1,c2)
	pass

def Status(sMsg):
	Widget('statusbar1').pop(0)
	Widget('statusbar1').push(0,sMsg)

def MessageBox(sMsg):
	global window
	dialog = gtk.MessageDialog(
		window,
		gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
		gtk.MESSAGE_INFO,
		gtk.BUTTONS_OK,
		sMsg
	)
	dialog.run()
	dialog.destroy()

def ErrorBox(sMsg):
	global window
	dialog = gtk.MessageDialog(
		window,
		gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
		gtk.MESSAGE_WARNING,
		gtk.BUTTONS_OK,
		sMsg
	)
	dialog.run()
	dialog.destroy()

def QuestionYesNoBox(sMsg):
	global window
	dialog = gtk.MessageDialog(
		window,
		gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
		gtk.MESSAGE_QUESTION,
		gtk.BUTTONS_YES_NO,
		sMsg
	)
	response = dialog.run()
	dialog.destroy()
	return response

def QuestionOKCancelBox(sMsg):
	global window
	dialog = gtk.MessageDialog(
		window,
		gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
		gtk.MESSAGE_QUESTION,
		gtk.BUTTONS_OK_CANCEL,
		sMsg
	)
	response = dialog.run()
	dialog.destroy()
	return response

def PrepareOpenFile(sTitleMessage):
	sFile = ''
	fb = gtk.FileSelection(sTitleMessage)
	fb.set_position(gtk.WIN_POS_CENTER)
	fb.set_filename(gsHomeDir)
	fb.show_all()
	result = fb.run()
	fb.hide()
	if (result == gtk.RESPONSE_OK):
		sFile = fb.get_filename()
		sFile = StrTrim(sFile)
		if ((StrRight(sFile, 1) == '/') or (sFile == '') or (sFile == '/')):
			MessageBox('No filename entered. Nothing opened.')
			return
	return sFile

def PrepareSaveFile(sTitleMessage, sFileExtension, bRootHomeSafety):
	fb = gtk.FileSelection(sTitleMessage)
	fb.set_position(gtk.WIN_POS_CENTER)
	fb.set_filename(gsHomeDir)
	fb.show_all()
	result = fb.run()
	fb.hide()
	if (result == gtk.RESPONSE_OK):
		sFile = fb.get_filename()
		sFile = StrTrim(sFile)
		if ((StrRight(sFile, 1) == '/') or (sFile == '') or (sFile == '/')):
			MessageBox('No filename entered. Nothing saved.')
			return
		sFileExtension = StrLCase(sFileExtension)
		if (StrLeft(sFileExtension, 1) != '.'):
			sFileExtension = '.' + sFileExtension
		if (StrLCase(StrRight(sFile, 4)) != sFileExtension):
			sFile = sFile + sFileExtension
		if (bRootHomeSafety):
			if ((StrLeft(sFile, 6) != '/root/') and (StrLeft(sFile, 6) != '/home/')):
				MessageBox('For your safety, this program can only save to \n/root and /home subdirectories.')
				return
		sCmd = 'file "' + sFile + '"'
		sResult = RunBash(sCmd)
		if not "can't stat" in sResult:
			result = QuestionYesNoBox("Do you wish to overwrite\n'" + sFile + "' ?")
			if (result != gtk.RESPONSE_YES):
				return
		return sFile

def StrTrim(sInput):
	return string.strip(sInput)

def StrLCase(sInput):
	return string.lower(sInput)

def StrUCase(sInput):
	return string.upper(sInput)

def StrLeft(sInput, nIndex):
	return sInput[:nIndex]

def StrRight(sInput, nIndex):
	return sInput[(nIndex * -1):]

def DisableWidget(sName):
	Widget(sName).set_property('sensitive',False)

def EnableWidget(sName):
	Widget(sName).set_property('sensitive',True)

def RemoveMenuItems(sMenu, nAfterMenuItem):
	i = 1
	for m in Widget(sMenu).get_children():
		if (i > nAfterMenuItem):
			Widget(sMenu).remove(m)
		i += 1

def AddMenuItem(sMenu, sLabel, sName, sImage, oSignal):
	mnu = gtk.ImageMenuItem(sLabel)
	mnu.set_name(sName)
	mnu.connect('activate', oSignal)
	Widget(sMenu).add(mnu)
	img = gtk.Image()
	img.set_from_file(sImage)
	mnu.set_image(img)
	img.show()
	mnu.show()
	return mnu

def AddSeparatorMenuItem(sMenu):
	mnu = gtk.SeparatorMenuItem()
	Widget(sMenu).add(mnu)
	mnu.show()

def gtk_main_quit(*args):
    gtk.main_quit()

def Refresh():
    while gtk.events_pending():
        gtk.main_iteration(False)

def QuitAll():
	Destroy('main')
#	subprocess.call(["gksudo", "vpnc-disconnect"])
	gtk.main_quit()

PROGNAME = 'GVPNC'

# load our Glade2 file with the GUI
MyWindows = gtk.glade.XML('gvpnc.glade',None,domain=PROGNAME)

# g var initizialization
window = None

# change whole app's font
Widget('main').get_settings().set_string_property('gtk-font-name', 'sans normal 9','')

# change font on the two main text fields
o = Widget('txtResult').get_buffer()
txtResultFont = o.create_tag('txtResultFont')
txtResultFont.set_property('font', 'Luxi Mono 8')

# connect our signals to our glade file object
MyWindows.signal_autoconnect(locals())

# make sure user configuration directory exists
os.umask(066)  #make sure only owner can access any files we create
if not os.path.exists(CONFIGDIR):
	os.makedirs(CONFIGDIR)

# show our main window and go into main loop
ShowWindow('main')
Widget('statusbar1').grab_focus()
gtk.main()
